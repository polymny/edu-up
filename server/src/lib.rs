//! This crate contains all the functions and structs required for the server.

#![warn(missing_docs)]
#![feature(proc_macro_hygiene, decl_macro)]

#[macro_use]
extern crate serde;
#[macro_use]
extern crate rocket;
#[macro_use]
extern crate rocket_contrib;
#[macro_use]
extern crate diesel;
#[macro_use]
extern crate diesel_derive_enum;

pub mod db;
pub mod mailer;
pub mod routes;
pub mod templates;

/// This module contains the database schema and is generated by diesel.
#[allow(missing_docs)]
pub mod generated_schema;

/// This module contains the part of the schema that cannot be automatically generated.
#[allow(missing_docs)]
pub mod schema;

use bcrypt::BcryptError;
use rocket::fairing::AdHoc;
use std::{error, fmt, io, result};

macro_rules! impl_from_error {
    ($type: ty, $variant: path, $from: ty) => {
        impl From<$from> for $type {
            fn from(e: $from) -> $type {
                $variant(e)
            }
        }
    };
}

/// The different errors that can occur when processing a request.
#[derive(Debug)]
pub enum Error {
    /// Couldn't connect to the database.
    DatabaseConnectionError(diesel::ConnectionError),

    /// Error while running a database request.
    DatabaseRequestError(diesel::result::Error),

    /// A session key was received but there was no such session.
    SessionDoesNotExist,

    /// A user try to log in but typed the wrong username or password.
    AuthenticationFailed,

    /// An argument is missing in a form.
    MissingArgumentInForm(String),

    /// An error occured while computing some bcrypt hash.
    BcryptError(BcryptError),

    /// An I/O error occured.
    IoError(io::Error),

    /// An error occured while trying to create a mail.
    MailError(lettre_email::error::Error),

    /// An error occured while trying to send a mail.
    SendMailError(lettre::smtp::error::Error),

    /// Empty Database request
    DatabaseRequestEmptyError(String),
}

impl_from_error!(
    Error,
    Error::DatabaseConnectionError,
    diesel::ConnectionError
);
impl_from_error!(Error, Error::DatabaseRequestError, diesel::result::Error);
impl_from_error!(Error, Error::BcryptError, BcryptError);
impl_from_error!(Error, Error::IoError, io::Error);
impl_from_error!(Error, Error::MailError, lettre_email::error::Error);
impl_from_error!(Error, Error::SendMailError, lettre::smtp::error::Error);

impl fmt::Display for Error {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Error::DatabaseConnectionError(e) => {
                write!(fmt, "failed to connect to the database: {}", e)
            }
            Error::DatabaseRequestError(e) => write!(fmt, "request to database failed: {}", e),
            Error::SessionDoesNotExist => write!(fmt, "there is not such session"),
            Error::AuthenticationFailed => write!(fmt, "authentication failed"),
            Error::MissingArgumentInForm(e) => write!(fmt, "missing argument \"{}\" in form", e),
            Error::BcryptError(e) => write!(fmt, "error in password hashing: {}", e),
            Error::IoError(e) => write!(fmt, "io error: {}", e),
            Error::MailError(e) => write!(fmt, "error sending mail: {}", e),
            Error::SendMailError(e) => write!(fmt, "error sending mail: {}", e),
            Error::DatabaseRequestEmptyError(e) => write!(fmt, "No database entry for: {}", e),
        }
    }
}

impl error::Error for Error {}

/// The result type of this library.
pub type Result<T> = result::Result<T, Error>;

use std::io::Cursor;

use rocket::http::{ContentType, Cookies};
use rocket::response::Response;

use rocket_contrib::databases::diesel as rocket_diesel;
use rocket_contrib::serve::StaticFiles;

use crate::db::user::User;
use crate::mailer::Mailer;
use crate::templates::{index_html, setup_html};

/// Our database type.
#[database("database")]
pub struct Database(rocket_diesel::PgConnection);

/// The index page.
#[get("/")]
pub fn index(db: Database, mut cookies: Cookies) -> Result<Response> {
    let user = cookies
        .get_private("EXAUTH")
        .map(|x| User::from_session(x.value(), &db).ok())
        .flatten();

    let user_and_projects = if let Some(user) = user.as_ref() {
        Some((user, user.projects(&db)?))
    } else {
        None
    };

    let flags = user_and_projects.map(|(user, projects)| {
        json!({
            "username": user.username,
            "projects": projects,
        })
    });

    let response = Response::build()
        .header(ContentType::HTML)
        .sized_body(Cursor::new(index_html(flags)))
        .finalize();

    Ok(response)
}

/// The route for the setup page, available only when Rocket.toml does not exist yet.
#[get("/")]
pub fn setup<'a>() -> Response<'a> {
    Response::build()
        .header(ContentType::HTML)
        .sized_body(Cursor::new(setup_html()))
        .finalize()
}

/// Starts the server.
pub fn main() {
    rocket::ignite()
        .attach(Database::fairing())
        .attach(AdHoc::on_attach("Mailer fairing", |rocket| {
            let mailer = Mailer::from_config(rocket.config());
            Ok(rocket.manage(mailer))
        }))
        .mount("/", routes![index])
        .mount("/", StaticFiles::from("dist"))
        .mount(
            "/api/",
            routes![
                routes::auth::new_user,
                routes::auth::activate,
                routes::auth::login,
                routes::auth::logout,
                routes::project::new_project,
                routes::project::get_project,
                routes::project::all_projects,
                routes::project::update_project,
                routes::project::delete_project,
                routes::project::project_upload,
                routes::capsule::new_capsule,
                routes::capsule::get_capsule,
                routes::capsule::all_capsules,
                routes::capsule::update_capsule,
                routes::capsule::delete_capsule,
                routes::capsule::upload_slides,
                routes::asset::get_asset,
                routes::asset::all_assets,
                routes::asset::delete_asset,
            ],
        )
        .launch()
        // This .kind() is here to prevent the server from panicking in case the config file is not
        // available. launch() returns an Error that when dropped, panics if it has not been
        // handled. Using .kind() here marks the error as handled.
        .kind();

    // If we arrive here, it means that the server failed to start.
    // Unless it's due to a programming mistake, this means that the configuration is broken.
    // In this case, we will spawn another server that asks for the configuration.
    rocket::ignite()
        .mount("/", routes![setup])
        .mount("/", StaticFiles::from("dist"))
        .mount(
            "/api/",
            routes![routes::setup::test_database, routes::setup::test_mailer],
        )
        .launch()
        .kind();
}
